<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>图解 Paxos 算法 | Ocavue&#39;s Blog</title>
    <meta name="description" content="Just playing around">
    
    
    <link rel="preload" href="/assets/css/0.styles.c77a0a89.css" as="style"><link rel="preload" href="/assets/js/app.3390545e.js" as="script"><link rel="preload" href="/assets/js/7.4335dcfb.js" as="script"><link rel="preload" href="/assets/js/5.13d50fda.js" as="script"><link rel="prefetch" href="/assets/js/10.3cc39aa1.js"><link rel="prefetch" href="/assets/js/11.ac7ff37e.js"><link rel="prefetch" href="/assets/js/12.6f0b04a4.js"><link rel="prefetch" href="/assets/js/13.8586ab88.js"><link rel="prefetch" href="/assets/js/14.2c8898b5.js"><link rel="prefetch" href="/assets/js/15.07692fc6.js"><link rel="prefetch" href="/assets/js/16.0fd9f730.js"><link rel="prefetch" href="/assets/js/17.62e65e2b.js"><link rel="prefetch" href="/assets/js/18.56cc483b.js"><link rel="prefetch" href="/assets/js/2.cdefbf3e.js"><link rel="prefetch" href="/assets/js/3.b05d599e.js"><link rel="prefetch" href="/assets/js/4.e52bb422.js"><link rel="prefetch" href="/assets/js/6.5bab4f56.js"><link rel="prefetch" href="/assets/js/8.da20465b.js"><link rel="prefetch" href="/assets/js/9.cc10bcad.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c77a0a89.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="root"><span class="cover" data-v-1164ecfe></span> <div class="sidebar" data-v-cf3bad4a><div class="sidebar__header" data-v-cf3bad4a><a href="/about.html" class="sidebar__header-avatar" style="background-image:url(https://ws1.sinaimg.cn/large/006tNc79gy1fom9qicqcej30e80e83zo.jpg);" data-v-cf3bad4a></a></div> <nav class="sidebar__nav" data-v-cf3bad4a><a href="/" class="sidebar__nav-item router-link-active" data-v-cf3bad4a><span class="sidebar__nav-item-icon icon-home" data-v-cf3bad4a></span> <span class="sidebar__nav-item-content" data-v-cf3bad4a>HOME</span></a> <a href="/about.html" class="sidebar__nav-item" data-v-cf3bad4a><span class="sidebar__nav-item-icon icon-face" data-v-cf3bad4a></span> <span class="sidebar__nav-item-content" data-v-cf3bad4a>ABOUT</span></a> <a href="/tag/" class="sidebar__nav-item" data-v-cf3bad4a><span class="sidebar__nav-item-icon icon-tag" data-v-cf3bad4a></span> <span class="sidebar__nav-item-content" data-v-cf3bad4a>TAGS</span></a></nav></div> <div class="toc" data-v-ea388812><a href="#节点故障的例子" class="toc__item" style="padding-left:16px;" data-v-ea388812>
        节点故障的例子
    </a><a href="#更加现实的情况" class="toc__item" style="padding-left:16px;" data-v-ea388812>
        更加现实的情况
    </a><a href="#paxos-的详细定义" class="toc__item" style="padding-left:16px;" data-v-ea388812>
        Paxos 的详细定义
    </a><a href="#参考资料" class="toc__item" style="padding-left:16px;" data-v-ea388812>
        参考资料
    </a></div> <header class="toolbar" data-v-5fd7a81e><span class="toolbar__button icon-menu" data-v-5fd7a81e></span> <a href="/" class="toolbar__item router-link-active" data-v-5fd7a81e>
        Ocavue's Blog
    </a> <span style="flex: 1;" data-v-5fd7a81e></span> <span class="toolbar__button icon-toc" data-v-5fd7a81e></span></header> <main class="app__main"><div class="post" data-v-a962948a><a href="/paxos.html" class="router-link-exact-active router-link-active post__img post__img--nolink" style="background-image:linear-gradient(to bottom, rgba(0, 0, 0, 0.05) 0%, rgba(0, 0, 0, 0.60) 100%), url('https://i.loli.net/2019/05/06/5ccfe8b2927cb.jpg');" data-v-a962948a><span class="post__img-title" data-v-a962948a>
            图解 Paxos 算法
        </span> <span class="post__img-info" data-v-a962948a><span data-v-a962948a>2019-01-09</span></span></a> <div class="post__content markdown-body" data-v-a962948a><div class="content default"><p><strong>一致性</strong>是分布式系统必须要解决的的问题，Paxos 算法就是解决分布式系统一致性的经典算法。在这篇文章中，我会用例子和图示讲解 Paxos 算法。</p> <p>我们先撇开细节和定义，直接用一个例子来直观地理解一下这个算法。</p> <p>想象一个用来卖票的分布式系统，就像 12306 那样。这个系统一共有五台机器，分布在不同的地点。为了讲解的方便，我们设定<strong>这个系统只卖一张票</strong>。五台机器有各自的数据库，用来储存买票者的名字。如果机器 A 认为把票卖给了我，而机器 B 认为把票卖给了你，那就糟糕了。于是我们要分布式系统的一致性，具体到这个例子就是保证不同机器中买票者的名字是同一个。</p> <p>此时机器 D 收到了来自 Alice 的买票请求。于是 D 首先进入 Prepare 阶段：,</p> <p>D 向其他 4 台机器发送了一条 <strong>提议</strong>（这里用<span style="color:#7EA6E0;"><em><strong>蓝色的箭头</strong></em></span>表示提议）：</p> <p><img src="/assets/img/1-1.db97f2bc.svg" alt=""></p> <p>其中 <code>P-1D</code> 表示：</p> <ol><li>这是一个提议（P for Prepare）</li> <li>提议的 ID 是 <code>1D</code></li></ol> <p>每个提议都需要一个递增的全局唯一 ID，最简单的方法就是当前时间加上当前机器的名字。这个 ID 会贯穿整个 Paxos 流程。值得注意的是，在提议阶段，D 并没有把购买者的名字 Alice 告诉其他机器。</p> <p>其他机器收到这个提议后，他们发现之前并没有收到过提议，于是同意了这份提议。具体来说是做了下面几件事：</p> <ol><li>将 <code>P-1D</code> 记录下来</li> <li>承诺以后不再接受 <code>ID &lt; &quot;1D&quot;</code> 的提议</li> <li>向 D 回复 OK，这里用<span style="color:#EA6B66;"><em><strong>红色的箭头</strong></em></span>表示对提议的回复</li></ol> <p><img src="/assets/img/1-2.43eab6b5.svg" alt=""></p> <p>D 收到其他机器的回复后，发现加上自己的同意，发现已经有超过半数的机器同意将票卖给 Alice（事实上，所有五台机器都同意这点）。即然多数派已经同意了这份提议，那么 D 就认为认为这个提议已经被通过了，于是进入了 Commit 阶段。</p> <p>在 Commit 阶段，D 向所有机器发出了一个<strong>决议</strong>（这里用<span style="color:#97D077;"><em><strong>绿色的箭头</strong></em></span>表示表示决议）：</p> <p><img src="/assets/img/1-3.e21e1637.svg" alt=""></p> <p>其中 <code>A-1D-Alice</code> 表示</p> <ul><li>这是一个决议（A for Accept）</li> <li>决议的 ID 是 <code>1D</code></li> <li>决议内容：将票卖给 Alice</li></ul> <p>其他四台机器到了这个决议后，就会把决议的内容记录下来，并返回给 D。D 最后把买票成功的消息发给 Alice，用图表示就是这样，这里用<span style="color:#B5739D;"><em><strong>紫色的箭头</strong></em></span>表示对决议的回复：</p> <p><img src="/assets/img/1-4.18e74816.svg" alt=""></p> <p>此时，所有五台机器都认为票卖给了 Alice，一致性得到了保证。</p> <p>上面的情况是所有机器和网络都能正常运行的理想情况，可使现实中总是不理想的，而分布式系统的最大价值之一就是能应对部分节点的故障，所以下面我们来模拟一下节点故障的情况。</p> <h2 id="节点故障的例子"><a href="#节点故障的例子" aria-hidden="true" class="header-anchor">#</a> 节点故障的例子</h2> <p>我们假设有两台机器 B 和 E 发生了故障，那么重复一下上面的步骤，看看会发生什么。</p> <p>第一步，D 接受到了 Alice 的请求，于是向其他机器<strong>发送提议</strong>：</p> <p><img src="/assets/img/2-1-1.41e5bb6e.svg" alt=""></p> <p>第二步，除了发生故障的 B 和 E，其他机器都<strong>回复了提议</strong>：</p> <p><img src="/assets/img/2-1-2.d2728ad3.svg" alt=""></p> <p>第三步，D 认为提议得到了多数派（A、C、D）的认可，于是向大家<strong>发送决议</strong></p> <p><img src="/assets/img/2-1-3.2cdd88fa.svg" alt=""></p> <p>第四步，除了故障机外，其他机器都<strong>回复了决议</strong>。最后 D 向 Alice 发送购票成功的消息。</p> <p><img src="/assets/img/2-1-4.6524a2fa.svg" alt=""></p> <p>到目前为止，一切都 OK。由于只有少数的机器发生了故障，依然有一个多数派（3 台机器 &gt; 5 台机器 / 2）存在，所以系统的运行没有受到影响。但是，如果我们这时候修好了 B 和 D，就会发现一个问题：B 和 D 就像刚苏醒的植物人，他们还以为这张票没卖出去呢！Paxos 算法如何解决这种情况呢？让我们继续这个例子：</p> <p><img src="/assets/img/2-2-1.71f9bacc.svg" alt=""></p> <blockquote><p>↑ B 和 E 恢复工作了，但是他们此时没有 <code>P-1D</code> 和 <code>C-1D-Alice</code> 的信息</p></blockquote> <p>假如这时候 Bob 来买票了，他向机器 B 发出了买票请求，于是 B 向其他机器发送了一个提议。</p> <p><img src="/assets/img/2-2-2.30dd88a4.svg" alt=""></p> <p>对于这个提议，E 的回复是 OK，但是 A、C 和 D 的回复是 <code>&quot;1B&quot; &lt; &quot;1D&quot;, Fail</code>。因为在之前，A、C、D 已经承诺过了，他们不会接受 <code>id &lt; &quot;1D&quot;</code> 的提议请求。</p> <p><img src="/assets/img/2-2-3.b8d8276f.svg" alt=""></p> <p>于是 B 只能放弃 <code>1B</code> 提议，而是紧接着又提出一个 ID 为 <code>2B</code> 提议，并将提议发送给其他机器：</p> <p><img src="/assets/img/2-2-4.f3b1a65e.svg" alt=""></p> <p>然后机器其他机器都同意了这个提议，不过 A、C 和 D 在同意提议的同时，还返回了这样一条信息：「我已经把票卖给 Alice 了，你不可能通知我把票买给其他人」：</p> <p><img src="/assets/img/2-2-5.1bab0969.svg" alt=""></p> <p>B 收到了包括自己在内的五分针对 <code>2B</code> 提议的同意，所以 B 可以进入下一步，也就是发表决议了。但是知道了票已经被 Alice 拿走后，由于卖掉的票是不能再拿回来的，所以 B 被迫修改决议的内容，也就是发表一个将票卖给 Alice 的决议，毕竟：</p> <p><img src="/assets/img/2-2-6.a0958537.svg" alt=""></p> <p>其他机器收到了这个决议后，也把这个决议写在自己的数据库中，并且将结果返回给 B。B 再通知 Bob 票已经被卖掉了：</p> <p><img src="/assets/img/2-2-7.d575120e.svg" alt=""></p> <p>在这个例子中，我们的分布式系统非常好地处理了节点故障的情况，最后达到的效果如下：</p> <ol><li>同一张票没有被卖给两个人。虽然 Bob 请求的机器 B 一开始并不知道票已经被 Alice 拿走了，但是最终 Bob 还是知道了。这就是最终一致性。</li> <li>最终所有机器上都储存了相同的信息，也就是 <code>P-2B</code> 和 <code>C-2B-Alice</code>。</li></ol> <h2 id="更加现实的情况"><a href="#更加现实的情况" aria-hidden="true" class="header-anchor">#</a> 更加现实的情况</h2> <p>同时处理多个 paxos 实例：</p> <p>在现实中，一个卖票系统不可能像上面的例子中只卖一张票。我们只要把每一张票当成一个独立的 paxos 算法流程，比如说在每个请求和响应中添加上票的唯一标示，就能从逻辑上同时处理多张票的售卖。</p> <p>*TODO添加图示</p> <p>票的转台</p> <p>我们做的另一个假设是一张票只会被卖出一次，但是在现实中由于可以退票，一张票可以在退票后卖个另一位顾客。在 paxos 中，我们需要引入状态机的概念：简单来说就有一个 状态 经过一个 操作 后变成了另一个状态。</p> <p>一张票被卖掉之后，它的状态由 可买 变成了 不可买，退票后其状态又重新变成了 可买。</p> <p>火车票的售卖 和 银行账号的余额 都可以表示为这样的逻辑：</p> <p><img src="/assets/img/sm.90659984.svg" alt=""></p> <p>只要知道初始状态和所有的操作，根据状态机的逻辑就能算出当前的状态。我们可以为每一个状态制定一个 Paxos 算法实例，所有机器上使用 Paxos 算法同步了状态 1, 2, 3, .... 这样就能在所有机器上都保存相同的记录。</p> <h2 id="paxos-的详细定义"><a href="#paxos-的详细定义" aria-hidden="true" class="header-anchor">#</a> Paxos 的详细定义</h2> <p>上面的例子中，整个流程并不是非常的严谨。为了更深入地理解 Paxos，我们需要在这里做一些枯燥的介绍。</p> <p>一个分布式系统中又若干个节点（上面的例子中一共有五个节点，也就是五台机器），在 Paxos 算法中，每个节点可能有三种角色：proposer、acceptor 和 learner。一个节点可以身担一个或者多个角色。其中 learner 并不会影响到决策本身，所以我们在这篇文章中不会涉及到 learner。</p> <p>Proposer 是提出提议（<em>prepare</em> request）和决议（<em>accept</em> request）的节点，acceptor 是接受提议和决议，并对其提议或者决议进行回复的节点。在上面的例子中，所有五个节点同时是 proposer 和 acceptor。</p> <p>下面是严谨地定义一次 Paxos 流程：这里我直接引用并翻译了论文原文，斜体的部分是我自己添加的一些解释：</p> <blockquote><p>Phase 1. (a) A proposer selects a proposal number <em>n</em> and sends a <em>prepare</em> request with number <em>n</em> to a majority of acceptors.</p> <p>(b) If an acceptor receives a <em>prepare</em> request with number <em>n</em> greater than that of any <em>prepare</em> request to which it has already responded, then it responds to the request with a promise not to accept any more proposals numbered less than n and with the highest-numbered proposal (if any) that it has accepted.</p> <p>Phase 2. (a) If the proposer receives a response to its <em>prepare</em> requests (numbered n) from a majority of acceptors, then it sends an <em>accept</em> request to each of those acceptors for a proposal numbered <em>n</em> with a value <em>v</em>, where <em>v</em> is the value of the highest-numbered proposal among the responses, or is any value if the responses reported no proposals.，</p> <p>(b) If an acceptor receives an <em>accept</em> request for a proposal numbered <em>n</em>, it accepts the proposal unless it has already responded to a <em>prepare</em> request having a number greater than <em>n</em>.</p></blockquote> <p><strong>阶段 1. (a) 一个 proposer 选择一个提议编号 <em>n</em>，然后将提议编号 <em>n</em> 放入 <em>prepare</em> request 中并发送给 acceptors 中的多数派。</strong></p> <p><em>在我们的例子中，proposer 会将 prepare request 发送给了所有的 acceptors，但是出于性能优化的考虑，即然它只需要大多数的 acceptors 同意，那么他可以只给 acceptors 中的一个多数派发送 prepare requests。具体发送给哪些 acceptors 由 proposer 自己决定。</em></p> <p><strong>(b) 如果一个 accptor 接受了一个 <em>prepare</em> request，其中的数字 <em>n</em> 大于这个 acceptor 已经回复过的所有 <em>prepare</em> request，那么他会回复这个 request，同时承诺不接受比 n 小的提议编号，而且会返回它已经接受过的提议中编号最大的那个提议（如果有的话）。</strong></p> <p><em>在我们上面的某张图中，（TODO，具体哪张图？），E 只返回了 OK，因为它之前没有接受过提议，但是 ACD 除了来返回 OK 之外，还返回了之前接受过的编号最大的提议，也就是 Alice</em></p> <p><strong>阶段 2. (a) 如果这个 proposer 收到了来自多数 acceptors 对 <em>prepare</em> requests (编号 n) 的回复，那么他会对这些 acceptors 分别发送一个 <em>accept</em> request，其中包含提议编号 <em>n</em> 和一个值 <em>v</em>。<em>v</em> 是响应中的提议中编号最大的那个提议的值，如果响应中没有提议，那 <em>v</em> 可以是任何值。</strong></p> <p>在图 2-1-3 和 2-2-6 中，proposer 发送了 accept request（绿色的箭头）。其中 2-1-3 中的 v 可以是任何值 ，这里 proposer 选择了 Alice，但是 <a href="#2-2-6">2-2-6</a> 中的</p> <p><strong>(b) 如果一个 acceptor 收到了一个带有提议编号 <em>n</em> 的 <em>accept</em> request，除非它已经回应过一个有着比 <em>n</em> 更大的编号的 <em>prepare</em> request ，它会接受这个提议。</strong></p> <h2 id="参考资料"><a href="#参考资料" aria-hidden="true" class="header-anchor">#</a> 参考资料</h2> <p><a href="https://zh.wikipedia.org/wiki/Paxos%E7%AE%97%E6%B3%95#%E5%AE%9E%E4%BE%8B" target="_blank" rel="noopener noreferrer">Paxos算法的维基百科页面<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="http://research.microsoft.com/users/lamport/pubs/paxos-simple.pdf" target="_blank" rel="noopener noreferrer">Paxos Made Simple<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> Lamport 于 2001年发布的论文。</p> <p>https://groups.csail.mit.edu/tds/papers/Lynch/jacm85.pdf FLP 不可能原理</p> <p>http://rystsov.info/2016/05/01/paxos.html 一个 Paxos 的 JavaScript 实现</p></div></div></div></main> <footer class="app__footer">
        Power by <a href="https://github.com/ocavue/vuepress-theme-blogue" class="app__footer-link">Blogue</a></footer> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.3390545e.js" defer></script><script src="/assets/js/7.4335dcfb.js" defer></script><script src="/assets/js/5.13d50fda.js" defer></script>
  </body>
</html>
